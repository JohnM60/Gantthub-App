package Reports;

import org.jfree.data.category.IntervalCategoryDataset;
import org.jfree.data.gantt.Task;
import org.jfree.data.gantt.TaskSeries;
import org.jfree.data.gantt.TaskSeriesCollection;

import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.*;

/**
 * Factory class to format Task data into data format needed by JFreeCharts
 */
public class GanttChartDatasetFactory {

    /**
     * Create dataset given a TaskSeries
     * @param series
     * @return IntervalCategoryDataset, needed by ChartFactory.createGanttChart
     */
    public static IntervalCategoryDataset CreateDataSet( TaskSeries series )
    {
        TaskSeriesCollection dataset = new TaskSeriesCollection();
        dataset.add(series);
        return dataset;
    }

    /**
     * Crate dataset given a list of TaskSeries
     * @param series, a list of series of tasks
     * @return IntervalCategoryDataset, needed by ChartFactory.createGanttChart
     */
    public static IntervalCategoryDataset CreateDataSet( ArrayList<TaskSeries> series )
    {
        TaskSeriesCollection dataset = new TaskSeriesCollection();
        for ( TaskSeries s : series) {
            dataset.add(s);
        }
        return dataset;
    }

    /**
     * Creates projected Series. Given a list of tasks, format data in such a way that it can be displayed in a Gantt Chart
     * @param name The title of task series
     * @param tasks list of Tasks generated by the user
     * @return org.jfree.data.gantt.TaskSeries
     */
    public static TaskSeries<String> CreateEstimateSeries(String name, List<entities.Task> tasks )
    {
        TaskSeries<String> series = new TaskSeries<String>(name);

        for ( entities.Task t : tasks)
        {
            if ( t.getStartDate() != null && t.getEndDate()!= null )
            {
                Task task = new Task(t.getTitle()
                        , Date.from(t.getStartDate().atStartOfDay().toInstant(ZoneOffset.UTC)),
                        Date.from(t.getEndDate().atStartOfDay().toInstant(ZoneOffset.UTC)) );

                series.add( task ); //resolution is only to the day. Can also add specific time if needed

                List<entities.Task> subtasks = getAllSubtasks(t);

                for ( entities.Task st : subtasks )
                {
                    if ( st.getStartDate() != null && st.getEndDate()!= null )
                    {
                        series.add( new Task(st.getTitle(), dateFromLocalDate(st.getStartDate()), dateFromLocalDate(st.getEndDate())) );
                    }
                }
            }

        }

        return series;
    }

    /**
     * Creates projected Series. Given a list of tasks, format data in such a way that it can be displayed in a Gantt Chart
     * @param name The title of task series
     * @param tasks list of Tasks generated by the user
     * @return org.jfree.data.gantt.TaskSeries
     */
    public static TaskSeries<String> CreateActualSeries(String name, List<entities.Task> tasks )
    {
        TaskSeries<String> series = new TaskSeries<String>(name);

        for ( entities.Task t : tasks)
        {
            if ( t.getActualStartDate() != null && t.getActualEndDate() != null)
            {
                Task task = new Task(t.getTitle()
                        , Date.from(t.getActualStartDate().atStartOfDay().toInstant(ZoneOffset.UTC)),
                        Date.from(t.getActualEndDate().atStartOfDay().toInstant(ZoneOffset.UTC)) );

                series.add( task ); //resolution is only to the day. Can also add specific time if needed

                List<entities.Task> subtasks = getAllSubtasks(t);

                for ( entities.Task st : subtasks )
                {
                    if ( st.getActualStartDate() != null && st.getActualEndDate() != null )
                    {
                        series.add( new Task(st.getTitle(),
                                dateFromLocalDate(st.getActualStartDate()),
                                dateFromLocalDate(st.getActualEndDate()))
                        );
                    }
                }
            }
        }

        return series;
    }

    private static List<entities.Task> getAllSubtasks(entities.Task task)
    {
        List<entities.Task> subtasks = new LinkedList<>();

        for ( entities.Task st : task.getSubTaskMap().values() )
        {
            getAllSubtasks(st, subtasks);
        }

        return subtasks;
    }

    private static List<entities.Task> getAllSubtasks(entities.Task task, List<entities.Task> subtasks)
    {
        subtasks.add(task);
        for ( entities.Task st : task.getSubTaskMap().values() )
        {
            getAllSubtasks(st, subtasks);
        }
        return subtasks;
    }


    /**
     * Convert localDate to Date
     * @param localDate
     * @return java.util.Date
     */
    private static Date dateFromLocalDate(LocalDate localDate)
    {
        return Date.from(localDate.atStartOfDay().toInstant(ZoneOffset.UTC));
    }

}
